
tmp1=bin(int(registers[rs],0))
tmp2=bin(int(registers[rt],0))
remain1=34-len(tmp1)
remain2=34-len(tmp2)
tmp1=tmp1[:2]+remain1*"0"+tmp1[2:]
tmp2=tmp2[:2]+remain2*"0"+tmp2[2:]
str1="0b"
str2="0b"
if (tmp1[2]=="1" and tmp2[2]=="1") :
    bin(int(tmp1,0)-1)
    for i in range(2,34) :
        if (tmp1[i]=="1") :
            str1+="0"
        elif (tmp1[i]=="0") :
            str1+="1"
    bin(int(tmp2,0)-1)
    for i in range(2,34) :
        if (tmp2[i]=="1") :
            str2+="0"
        elif (tmp2[i]=="0") :
            str2+="1"
    compute=("0x00000001" if ( int(str2,0)<int(str1,0)) else "0x00000000")
elif (tmp1[2]=="1" and tmp2[2]=="0") :
    compute="0x00000001"
elif (tmp1[2]=="0" and tmp2[2]=="1") :
    compute="0x00000000"
else :
    compute=("0x00000001" if ( int(registers[rs],0)<int(registers[rt],0)) else "0x00000000")
registers[rd]=compute












python3 main.py
mips-sim> loadinst ../testCase1.bin
mips-sim> run 100
unknown instruction
Executed 11 instructions
mips-sim> registers
$0: 0x00000000
$1: 0xffffffff
$2: 0xff000000
$3: 0x00000010
$4: 0xffff0000
$5: 0xffff0000
$6: 0xffffff00
$7: 0xffffffff
$8: 0x00ffff00
$9: 0x0000ffff
$10: 0x00000000
$11: 0x00000000
$12: 0x00000000
$13: 0x00000000
$14: 0x00000000
$15: 0x00000000
$16: 0x00000000
$17: 0x00000000
$18: 0x00000000
$19: 0x00000000
$20: 0x00000000
$21: 0x00000000
$22: 0x00000000
$23: 0x00000000
$24: 0x00000000
$25: 0x00000000
$26: 0x00000000
$27: 0x00000000
$28: 0x00000000
$29: 0x00000000
$30: 0x00000000
$31: 0x00000000
PC: 0x0000002c

mips-sim> loadinst ../testCase3.bin
mips-sim> run 100
unknown instruction
Executed 17 instructions
mips-sim> registers

inst 0: 3401ffff ori $1, $0, -1
inst 1: 3402ffff ori $2, $0, -1
inst 2: 00221820 add $3, $1, $2
inst 3: 20040003 addi $4, $0, 3
inst 4: 20050004 addi $5, $0, 4
inst 5: 20067a73 addi $6, $0, 31347
inst 6: 2007000a addi $7, $0, 10
inst 7: 24088000 addiu $8, $0, -32768
inst 8: 00854820 add $9, $4, $5
inst 9: 00855021 addu $10, $4, $5
inst 10: 00a65820 add $11, $5, $6
inst 11: 00c76020 add $12, $6, $7
inst 12: 00856822 sub $13, $4, $5
inst 13: 00a47022 sub $14, $5, $4
inst 14: 00857823 subu $15, $4, $5
inst 15: 00a48023 subu $16, $5, $4


$0: 0x00000000
$1: 0x0000ffff
$2: 0x0000ffff
$3: 0x0001fffe
$4: 0x00000003
$5: 0x00000004
$6: 0x00007a73
$7: 0x0000000a
$8: 0xffff8000
$9: 0x00000007
$10: 0x00000007
$11: 0x00007a77
$12: 0x00007a7d
$13: 0xffffffff
$14: 0x00000001
$15: 0xffffffff
$16: 0x00000001
$17: 0x00000000
$18: 0x00000000
$19: 0x00000000
$20: 0x00000000
$21: 0x00000000
$22: 0x00000000
$23: 0x00000000
$24: 0x00000000
$25: 0x00000000
$26: 0x00000000
$27: 0x00000000
$28: 0x00000000
$29: 0x00000000
$30: 0x00000000
$31: 0x00000000
PC: 0x00000044

mips-sim> loadinst ../testCase4.bin
mips-sim> run 100
unknown instruction
Executed 6 instructions
mips-sim> registers


inst 0: 3c018000 lui $1, -32768
inst 1: 3c027fff lui $2, 32767
inst 2: 3442ffff ori $2, $2, -1
inst 3: 0022182a slt $3, $1, $2
inst 4: 0022202b sltv $4, $1, $2


$0: 0x00000000
$1: 0x80000000
$2: 0x7fffffff
$3: 0x00000001
$4: 0x00000000
$5: 0x00000000
$6: 0x00000000
$7: 0x00000000
$8: 0x00000000
$9: 0x00000000
$10: 0x00000000
$11: 0x00000000
$12: 0x00000000
$13: 0x00000000
$14: 0x00000000
$15: 0x00000000
$16: 0x00000000
$17: 0x00000000
$18: 0x00000000
$19: 0x00000000
$20: 0x00000000
$21: 0x00000000
$22: 0x00000000
$23: 0x00000000
$24: 0x00000000
$25: 0x00000000
$26: 0x00000000
$27: 0x00000000
$28: 0x00000000
$29: 0x00000000
$30: 0x00000000
$31: 0x00000000
PC: 0x00000018

mips-sim> loadinst ../testCase5.bin
mips-sim> run 100
unknown instruction
Executed 20 instructions
mips-sim> registers

inst 0: 38015555 xori $1, $0, 21845
inst 1: 3402ffff ori $2, $0, -1
inst 2: 3023b68c andi $3, $1, -18804
inst 3: 00222024 and $4, $1, $2
inst 4: 00232824 and $5, $1, $3
inst 5: 00223027 nor $6, $1, $2
inst 6: 00233827 nor $7, $1, $3
inst 7: 00234025 or $8, $1, $3
inst 8: 00224826 xor $9, $1, $2
inst 9: 00435026 xor $10, $2, $3
inst 10: 00235826 xor $11, $1, $3
inst 11: 3c0c7fff lui $12, 32767
inst 12: 358cffff ori $12, $12, -1
inst 13: 3c0dffff lui $13, -1
inst 14: 35adffff ori $13, $13, -1
inst 15: 298effff slti $14, $12, -1
inst 16: 2d8fffff sltiu $15, $12, -1
inst 17: 29b00001 slti $16, $13, 1
inst 18: 2db10001 sltiu $17, $13, 1


$0: 0x00000000
$1: 0x00005555
$2: 0x0000ffff
$3: 0x00001404
$4: 0x00005555
$5: 0x00001404
$6: 0xffff0000
$7: 0xffffaaaa
$8: 0x00005555
$9: 0x0000aaaa
$10: 0x0000ebfb
$11: 0x00004151
$12: 0x7fffffff
$13: 0xffffffff
$14: 0x00000000
$15: 0x00000001
$16: 0x00000001
$17: 0x00000000
$18: 0x00000000
$19: 0x00000000
$20: 0x00000000
$21: 0x00000000
$22: 0x00000000
$23: 0x00000000
$24: 0x00000000
$25: 0x00000000
$26: 0x00000000
$27: 0x00000000
$28: 0x00000000
$29: 0x00000000
$30: 0x00000000
$31: 0x00000000
PC: 0x00000050




---------------------------------------------------------------------------------------------------------------------

proj2

* 명령 수행 후 PC 값 4 증가

---------------------------------------------------------------------------------------------------------------
// R-format 

add       R type  /  add $rd, $rs, $rt      /  op = 0 / shamt = 0 / funct  = 32 
- rd = rs+rt, 원래는 overflow 체크까지 해줌 -> 이번 프로젝트에서는 무시(addu랑 동일하게 작동)

addu     R type /   addu $rd, $rs, $rt    /  op =0 / shamt = 0 / funct = 33 
- rd = rs+rt, overflow 체크 안함

and       R type /   and $rd, $rs, $rt     / op = 0 / shamt = 0 / funct = 36  
- rd = rs & rt

nor       R type /  nor $rd, $rs, $rt       /  op =0 / shamt = 0 / funct = 39 
- rd=~(rs|rt)

or         R type /  or $rd, $rs, $rt        /  op =0 / shamt = 0 / funct = 37
- rd=rs|rt

slt         R type /  slt $rd, $rs, $rt       / op = 0 / shamt = 0/ funct = 42 
- rd = (rs < rt) ? 1 : 0

sltu        R type /  sltu $rd, $rs, $rt     / op = 0 / shamt = 0/ funct = 43 
- rd = (rs < rt) ? 1 : 0

sub         R type  /  sub $rd, $rs, $rt      /  op = 0 / shamt = 0 / funct  = 34
- rd = rs-rt, overflow chk(무시)

subu       R type  /  subu $rd, $rs, $rt      /  op = 0 / shamt = 0 / funct  = 35
- rd = rs-rt

xor         R type  /  xor $rd, $rs, $rt      /  op = 0 / shamt = 0 / funct  = 38
- rd = rs^rt


-------------------------------------------------------------------------------------------------------
// Shift 

sll         R type /  sll $rd, $rt, sa         / op = 0 / funct = 0 
- rd = rt<<sa

sllv        R type /  sllv $rd, $rt, $rs      / op = 0 / shamt = 0/ funct = 4 
- rd = rt<< rs

sra         R type /  sra $rd, $rt, sa        / op = 0 / rs = 0 / funct = 3  
- rd= rt>>sa

srav        R type /  srav $rd, $rt, $rs     / op = 0 /  funct = 7  
- rd= rt>>rs

srl          R type /  srl $rd, $rt, sa        / op = 0 / funct = 2 
- rd= rt>>sa

srlv         R type /  srlv $rd, $rt, $rs       / op = 0 / shamt = 0 / funct = 6
- rd=rt>>rs

-------------------------------------------------------------------------------------------------------
// I-format

addi        i type  / addi $rt, $rs, imm    /  op = 8
- rt = rs+imm

addiu      i type  / addiu $rt, $rs, imm    /  op = 9
- rt = rs+imm

andi        i type  / andi $rt, $rs, imm     /   op = 12
- rt = rs&imm

lui          i type  / lui $rt, imm    /   op = 15
- rt = imm<<16

ori          i type  / ori $rt, $rs, imm    /   op = 13
- rt=rs|imm

slti          i type  / slti $rt, $rs, imm    /   op = 10
- rt= (rs<imm) ? 1 : 0

sltiu         i type  / sltiu $rt, $rs, imm    /   op = 11
- rt= (rs<imm) ? 1 : 0

xori         i type  / xori $rt, $rs, imm    /   op = 14
- rt=rs^imm
